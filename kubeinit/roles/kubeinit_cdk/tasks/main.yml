---
# Copyright kubeinit contributors
# All Rights Reserved.
#
# Licensed under the Apache License, Version 2.0 (the "License"); you may
# not use this file except in compliance with the License. You may obtain
# a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
# WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
# License for the specific language governing permissions and limitations
# under the License.

- name: Prepare services if needed
  ansible.builtin.include_role:
    name: "../../roles/kubeinit_services"
    tasks_from: prepare_services.yml
    public: true
  vars:
    task_completed: "{{ hostvars['kubeinit-facts'] is defined }}"
  when: not task_completed

- block:
    - name: Check to see if we should stop here
      ansible.builtin.debug: msg="Stopping before '{{ kubeinit_stop_before_task }}'"
    - name: End play
      ansible.builtin.meta: end_play
  when: kubeinit_stop_before_task is defined and kubeinit_stop_before_task == 'task-deploy-cluster'

- name: Deploy the cluster nodes
  ansible.builtin.include_role:
    name: "../../roles/kubeinit_libvirt"
    tasks_from: "deploy_{{ kubeinit_deployment_os }}_guest.yml"
    public: yes
  loop: "{{ groups['all_cluster_nodes'] + groups['extra_nodes'] }}"
  loop_control:
    loop_var: cluster_role_item
  vars:
    kubeinit_deployment_node_name: "{{ cluster_role_item }}"
    kubeinit_deployment_delegate: "{{ hostvars[cluster_role_item].target }}"
    kubeinit_deployment_os: "{{ hostvars[cluster_role_item].os }}"
    kubeinit_deployment_role: cluster
  when: kubeinit_cluster_nodes_deployed is not defined or not kubeinit_cluster_nodes_deployed

- name: Add cluster authorized keys in cluster nodes
  ansible.posix.authorized_key:
    user: root
    key: "{{ authorized_key }}"
    state: present
  loop: "{{ (groups['all_cluster_nodes'] + groups['extra_nodes']) | product(kubeinit_cluster_hostvars.authorized_keys) }}"
  vars:
    cluster_node: "{{ item[0] }}"
    authorized_key: "{{ item[1] }}"
  delegate_to: "{{ cluster_node }}"

- name: Render the cluster template
  ansible.builtin.template:
    src: "cloud.yml.j2"
    dest: "~/cloud.yml"
    mode: '0644'
  delegate_to: "{{ kubeinit_provision_service_node }}"

- name: Render the bundle template
  ansible.builtin.template:
    src: "bundle.yml.j2"
    dest: "~/bundle.yml"
    mode: '0644'
  delegate_to: "{{ kubeinit_provision_service_node }}"

- name: Add host keys to known_hosts
  ansible.builtin.known_hosts:
    name: "{{ hostvars[item].ansible_host }}"
    key: "{{ hostvars[item].ansible_host }} {{ hostvars[item].ssh_host_key_ecdsa }}"
    state: present
  with_items:
    - "{{ groups['all_cluster_nodes'] }}"
    - "{{ groups['extra_nodes'] }}"
  delegate_to: "{{ kubeinit_provision_service_node }}"

- name: Install the CDK juju installer
  ansible.builtin.shell: |
    set -eo pipefail
    wget {{ kubeinit_cdk_juju_uri }}
    xzcat {{ kubeinit_cdk_juju_file }} | (cd /usr/bin; tar xvf - ./juju)
  args:
    executable: /bin/bash
  register: _result
  changed_when: "_result.rc == 0"
  delegate_to: "{{ kubeinit_provision_service_node }}"

- name: Add the CDK cluster
  ansible.builtin.shell: |
    juju add-cloud --client {{ kubeinit_inventory_cluster_name }} -f cloud.yml
  args:
    executable: /bin/bash
  register: _result
  changed_when: "_result.rc == 0"
  delegate_to: "{{ kubeinit_provision_service_node }}"

- name: Bootstrap the CDK controller
  ansible.builtin.shell: |
    juju bootstrap --no-gui \
        --debug \
        --bootstrap-series=focal \
        manual/root@{{ hostvars[groups['extra_nodes'][0]].ansible_host }} > juju-bootstrap.log 2>&1
  args:
    executable: /bin/bash
  register: _result
  changed_when: "_result.rc == 0"
  delegate_to: "{{ kubeinit_provision_service_node }}"

- name: Show juju info
  ansible.builtin.shell: |
    juju controllers
    juju status --format=yaml
  args:
    executable: /bin/bash
  register: _result
  changed_when: "_result.rc == 0"
  delegate_to: "{{ kubeinit_provision_service_node }}"

- name: Add machines
  ansible.builtin.shell: |
    juju add-machine --debug ssh:root@{{ hostvars[item].ansible_host }} > juju-add-machine-{{ item }}.log 2>&1
  args:
    executable: /bin/bash
  register: _result
  changed_when: "_result.rc == 0"
  with_items:
    - "{{ groups['all_cluster_nodes'] }}"
  delegate_to: "{{ kubeinit_provision_service_node }}"

- name: Verify that all cluster nodes are started
  ansible.builtin.shell: |
    set -o pipefail
    juju machines | grep started
  args:
    executable: /bin/bash
  register: _result
  changed_when: "_result.rc == 0"
  retries: 60
  delay: 60
  delegate_to: "{{ kubeinit_provision_service_node }}"
  until: _result.stdout_lines | list | count == ( groups['all_cluster_nodes'] | count )

- name: Deploy CDK
  ansible.builtin.shell: |
    juju deploy ./bundle.yml --force --map-machines=existing{% for item in groups['all_cluster_nodes'] -%},{{ loop.index0 }}={{ loop.index0 }}{%- endfor %}
  args:
    executable: /bin/bash
  register: _result
  changed_when: "_result.rc == 0"
  retries: 20
  delegate_to: "{{ kubeinit_provision_service_node }}"
  until: _result.rc == 0

- name: Get cluster status
  ansible.builtin.shell: |
    juju status
  args:
    executable: /bin/bash
  register: _result
  changed_when: "_result.rc == 0"
  delegate_to: "{{ kubeinit_provision_service_node }}"

- name: Verify that the etcd cluster is up and healthy
  ansible.builtin.shell: |
    set -o pipefail
    juju status --format=json | sed 's/application-status/application_status/g' | jq -r .applications.etcd.application_status.message
  args:
    executable: /bin/bash
  vars:
    all_controllers_healthy_text: "Healthy with {{ kubeinit_controller_count }} known peer{{ 's' if (kubeinit_controller_count | int > 1) }}"
  register: _result
  changed_when: "_result.rc == 0"
  retries: 100
  delay: 60
  delegate_to: "{{ kubeinit_provision_service_node }}"
  until: all_controllers_healthy_text == _result.stdout

- name: Create kube directory
  ansible.builtin.file:
    path: ~/.kube
    state: directory
    mode: '0755'
  delegate_to: "{{ kubeinit_provision_service_node }}"

- name: Make sure the kubeconfig file exists in the first controller node
  ansible.builtin.stat:
    path: ~/.kube/config
  register: _result
  retries: 60
  delay: 60
  until: _result.stat.exists
  delegate_to: "{{ kubeinit_first_controller_node }}"

- name: Copy the kubeconfig to a variable
  ansible.builtin.slurp:
    src: ~/.kube/config
  register: _result_cluster_kubeconfig
  delegate_to: "{{ kubeinit_first_controller_node }}"

- name: Storing the master kubeconfig to the services machine.
  ansible.builtin.copy:
    content: "{{ _result_cluster_kubeconfig.content | default('Empty file') | b64decode }}"
    dest: ~/.kube/config
    mode: '0644'
  delegate_to: "{{ kubeinit_provision_service_node }}"

- name: Autoload kubeconfig
  ansible.builtin.shell: |
    echo "export KUBECONFIG=~/.kube/config" >> ~/.bashrc
  args:
    executable: /bin/bash
  register: _result
  changed_when: "_result.rc == 0"
  delegate_to: "{{ kubeinit_provision_service_node }}"

- name: Add task-deploy-cluster to tasks_completed
  ansible.builtin.add_host:
    name: "{{ kubeinit_cluster_facts_name }}"
    tasks_completed: "{{ kubeinit_cluster_hostvars.tasks_completed | union(['task-deploy-cluster']) }}"

- name: Update kubeinit_cluster_hostvars
  ansible.builtin.set_fact:
    kubeinit_cluster_hostvars: "{{ hostvars[kubeinit_cluster_facts_name] }}"

- block:
    - name: Check to see if we should stop here
      ansible.builtin.debug: msg="Stopping after '{{ kubeinit_stop_after_task }}'"
    - name: End play
      ansible.builtin.meta: end_play
  when: kubeinit_stop_after_task is defined and kubeinit_stop_after_task in kubeinit_cluster_hostvars.tasks_completed
